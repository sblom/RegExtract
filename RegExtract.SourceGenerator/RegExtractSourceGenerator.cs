using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace RegExtract.SourceGenerator
{
    [Generator]
    public class RegExtractSourceGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new RegExtractSyntaxReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            if (context.SyntaxReceiver is not RegExtractSyntaxReceiver receiver)
                return;

            var sourceBuilder = new StringBuilder();
            sourceBuilder.AppendLine("// <auto-generated />");
            sourceBuilder.AppendLine("using System;");
            sourceBuilder.AppendLine("using System.Text.RegularExpressions;");
            sourceBuilder.AppendLine("using RegExtract;");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine("namespace RegExtract.Generated");
            sourceBuilder.AppendLine("{");

            bool hasGeneratedAnyCode = false;

            foreach (var candidateType in receiver.CandidateTypes)
            {
                var semanticModel = context.Compilation.GetSemanticModel(candidateType.SyntaxTree);
                var typeSymbol = semanticModel.GetDeclaredSymbol(candidateType);

                if (typeSymbol is null)
                    continue;

                // Find the REGEXTRACT_REGEX_PATTERN field
                var regexPatternField = typeSymbol.GetMembers("REGEXTRACT_REGEX_PATTERN")
                    .OfType<IFieldSymbol>()
                    .FirstOrDefault(f => f.IsStatic && f.DeclaredAccessibility == Accessibility.Public && f.Type.SpecialType == SpecialType.System_String);

                if (regexPatternField is null)
                    continue;

                var regexPattern = GetConstantValue(regexPatternField);
                if (regexPattern is null)
                    continue;

                // Generate the extraction plan for this type
                GenerateExtractionPlanForType(sourceBuilder, typeSymbol, regexPattern);
                hasGeneratedAnyCode = true;
            }

            sourceBuilder.AppendLine("}");

            if (hasGeneratedAnyCode)
            {
                context.AddSource("RegExtractGenerated.cs", SourceText.From(sourceBuilder.ToString(), Encoding.UTF8));
            }
        }

        private string? GetConstantValue(IFieldSymbol field)
        {
            if (field.HasConstantValue && field.ConstantValue is string value)
                return value;
            return null;
        }

        private void GenerateExtractionPlanForType(StringBuilder sourceBuilder, ITypeSymbol typeSymbol, string regexPattern)
        {
            var typeName = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var simpleTypeName = typeSymbol.Name;

            sourceBuilder.AppendLine($"    public static class {simpleTypeName}ExtractionPlan");
            sourceBuilder.AppendLine("    {");
            sourceBuilder.AppendLine($"        private static readonly Regex _regex = new Regex(@\"{EscapeRegexPattern(regexPattern)}\");");
            sourceBuilder.AppendLine($"        private static readonly ExtractionPlan<{typeName}> _plan = ExtractionPlan<{typeName}>.CreatePlan(_regex);");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine($"        public static {typeName}? Extract(string input)");
            sourceBuilder.AppendLine("        {");
            sourceBuilder.AppendLine("            return _plan.Extract(input);");
            sourceBuilder.AppendLine("        }");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine($"        public static {typeName}? Extract(Match match)");
            sourceBuilder.AppendLine("        {");
            sourceBuilder.AppendLine("            return _plan.Extract(match);");
            sourceBuilder.AppendLine("        }");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine($"        public static ExtractionPlan<{typeName}> Plan => _plan;");
            sourceBuilder.AppendLine("    }");
            sourceBuilder.AppendLine();
        }

        private string EscapeRegexPattern(string pattern)
        {
            return pattern.Replace("\"", "\"\"");
        }
    }

    internal class RegExtractSyntaxReceiver : ISyntaxReceiver
    {
        public List<TypeDeclarationSyntax> CandidateTypes { get; } = new List<TypeDeclarationSyntax>();

        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
        {
            if (syntaxNode is TypeDeclarationSyntax typeDeclaration)
            {
                // Check if this type has a REGEXTRACT_REGEX_PATTERN field
                var hasRegexPatternField = typeDeclaration.Members
                    .OfType<FieldDeclarationSyntax>()
                    .Any(field => field.Declaration.Variables
                        .Any(variable => variable.Identifier.ValueText == "REGEXTRACT_REGEX_PATTERN"));

                if (hasRegexPatternField)
                {
                    CandidateTypes.Add(typeDeclaration);
                }
            }
        }
    }
}