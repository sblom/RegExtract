using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace RegExtract.SourceGenerator
{
    [Generator]
    public class RegExtractSourceGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new RegExtractSyntaxReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            // Always generate a simple test file to verify the generator is running
            var testSource = new StringBuilder();
            testSource.AppendLine("// <auto-generated />");
            testSource.AppendLine("// This file is generated by RegExtractSourceGenerator");
            testSource.AppendLine("namespace RegExtract.Generated");
            testSource.AppendLine("{");
            testSource.AppendLine("    public static class SourceGeneratorTest");
            testSource.AppendLine("    {");
            testSource.AppendLine("        public static string GetMessage() => \"Source generator is working!\";");
            testSource.AppendLine("    }");
            testSource.AppendLine("}");
            
            context.AddSource("SourceGeneratorTest.cs", SourceText.From(testSource.ToString(), Encoding.UTF8));

            if (context.SyntaxReceiver is not RegExtractSyntaxReceiver receiver)
                return;

            var sourceBuilder = new StringBuilder();
            sourceBuilder.AppendLine("// <auto-generated />");
            sourceBuilder.AppendLine("// Debug: Source generator executed");
            sourceBuilder.AppendLine($"// Debug: Found {receiver.CandidateTypes.Count} candidate types");
            sourceBuilder.AppendLine("using System;");
            sourceBuilder.AppendLine("using System.Text.RegularExpressions;");
            sourceBuilder.AppendLine("using RegExtract;");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine("namespace RegExtract.Generated");
            sourceBuilder.AppendLine("{");

            bool hasGeneratedAnyCode = false;

            foreach (var candidateType in receiver.CandidateTypes)
            {
                sourceBuilder.AppendLine($"    // Debug: Processing type {candidateType.Identifier.ValueText}");
                
                var semanticModel = context.Compilation.GetSemanticModel(candidateType.SyntaxTree);
                var typeSymbol = semanticModel.GetDeclaredSymbol(candidateType);

                if (typeSymbol is null)
                {
                    sourceBuilder.AppendLine($"    // Debug: Type symbol is null for {candidateType.Identifier.ValueText}");
                    continue;
                }

                sourceBuilder.AppendLine($"    // Debug: Type symbol found: {typeSymbol.Name}");
                sourceBuilder.AppendLine($"    // Debug: Members count: {typeSymbol.GetMembers().Length}");
                
                foreach (var member in typeSymbol.GetMembers())
                {
                    sourceBuilder.AppendLine($"    // Debug: Member: {member.Name} ({member.Kind})");
                    if (member is IFieldSymbol field)
                    {
                        sourceBuilder.AppendLine($"    //   Field details: IsConst={field.IsConst}, IsStatic={field.IsStatic}, Access={field.DeclaredAccessibility}, Type={field.Type.Name}");
                    }
                }

                // Find the REGEXTRACT_REGEX_PATTERN field
                var regexPatternField = typeSymbol.GetMembers("REGEXTRACT_REGEX_PATTERN")
                    .OfType<IFieldSymbol>()
                    .FirstOrDefault(f => f.IsConst && f.DeclaredAccessibility == Accessibility.Public && f.Type.SpecialType == SpecialType.System_String);

                if (regexPatternField is null)
                {
                    sourceBuilder.AppendLine($"    // Debug: No REGEXTRACT_REGEX_PATTERN field found for {typeSymbol.Name}");
                    continue;
                }

                sourceBuilder.AppendLine($"    // Debug: Pattern field found: {regexPatternField.Name}");

                var regexPattern = GetConstantValue(regexPatternField);
                if (regexPattern is null)
                {
                    sourceBuilder.AppendLine($"    // Debug: Pattern value is null for {typeSymbol.Name}");
                    continue;
                }

                sourceBuilder.AppendLine($"    // Debug: Pattern value: {regexPattern}");

                // Generate the extraction plan for this type
                GenerateExtractionPlanForType(sourceBuilder, typeSymbol, regexPattern);
                hasGeneratedAnyCode = true;
            }

            sourceBuilder.AppendLine("}");

            // Always generate the file so we can see debug output
            context.AddSource("RegExtractGenerated.cs", SourceText.From(sourceBuilder.ToString(), Encoding.UTF8));
        }

        private string? GetConstantValue(IFieldSymbol field)
        {
            if (field.HasConstantValue && field.ConstantValue is string value)
                return value;
            return null;
        }

        private void GenerateExtractionPlanForType(StringBuilder sourceBuilder, ITypeSymbol typeSymbol, string regexPattern)
        {
            var typeName = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var simpleTypeName = typeSymbol.Name;

            sourceBuilder.AppendLine($"    public static class {simpleTypeName}ExtractionPlan");
            sourceBuilder.AppendLine("    {");
            sourceBuilder.AppendLine($"        private static readonly Regex _regex = new Regex(@\"{EscapeRegexPattern(regexPattern)}\");");
            sourceBuilder.AppendLine($"        private static readonly ExtractionPlan<{typeName}> _plan = ExtractionPlan<{typeName}>.CreatePlan(_regex);");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine($"        public static {typeName}? Extract(string input)");
            sourceBuilder.AppendLine("        {");
            sourceBuilder.AppendLine("            return _plan.Extract(input);");
            sourceBuilder.AppendLine("        }");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine($"        public static {typeName}? Extract(Match match)");
            sourceBuilder.AppendLine("        {");
            sourceBuilder.AppendLine("            return _plan.Extract(match);");
            sourceBuilder.AppendLine("        }");
            sourceBuilder.AppendLine();
            sourceBuilder.AppendLine($"        public static ExtractionPlan<{typeName}> Plan => _plan;");
            sourceBuilder.AppendLine("    }");
            sourceBuilder.AppendLine();
        }

        private string EscapeRegexPattern(string pattern)
        {
            return pattern.Replace("\"", "\"\"");
        }
    }

    internal class RegExtractSyntaxReceiver : ISyntaxReceiver
    {
        public List<TypeDeclarationSyntax> CandidateTypes { get; } = new List<TypeDeclarationSyntax>();

        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
        {
            if (syntaxNode is TypeDeclarationSyntax typeDeclaration)
            {
                // Check if this type has a REGEXTRACT_REGEX_PATTERN field
                var hasRegexPatternField = typeDeclaration.Members
                    .OfType<FieldDeclarationSyntax>()
                    .Any(field => field.Declaration.Variables
                        .Any(variable => variable.Identifier.ValueText == "REGEXTRACT_REGEX_PATTERN"));

                if (hasRegexPatternField)
                {
                    CandidateTypes.Add(typeDeclaration);
                }
            }
        }
    }
}